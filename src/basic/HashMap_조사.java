package basic;

import java.util.HashMap;
import java.util.Map;

public class HashMap_조사 {
    public static void main(String[] args) {
        /*
        Map: 인터페이스
        Map 인터페이스 구현방식에 따라서 HashMap, TreeMap, LinkedHashMap 등으로 구분될 수 있다.
        모두 기본적으로 key-value의 형태로 데이터를 저장한다.
         */

        /**
         * 해시함수
         * - 임의의 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑해주는 함수
         *
         * HashMap
         * - https://onsil-thegreenhouse.github.io/programming/java/2018/02/22/java_tutorial_HashMap_bucket/
         *
         * 내부에 Entry 배열을 관리한다.
         * HashMap은 버킷의 위치를 정할 때 객체의 해시코드를 사용합니다.
         * (버킷 == ArrayList)
         * 최초에 capacity = 16, load_factor = 0.75로하여 버킷이 생성된다.
         *  => 버킷의 크기는 16개이다.
         *
         * HashMap을 비롯한 많은 해시함수에서는 메모리를 절약하기 위해서 표현해야 할 범위 N보다 적은 M만큼의 배열을 사용한다.
         * Number 객체는 충동 없이 완전한 해시함수로 표현 할 수 있음
         * 하지만, String, POJO의 경우에는 충돌이 있을 수 있음
         * >> 해시코드의 결과형은 int형이다. 2^32개까지 표현이 가능하다. == 완전히 중복이 없는 상태로 만들 수는 없음
         * int index = X.hashCode() % M;
         *
         */
        Map<Integer, Integer> map = new HashMap<>();
        map.put(10, 10);    // 10.hashcode() % 16 = 10번째 버킷에 저장
        map.put(16, 9);     // 16.hashcode() % 16 = 0번째 버킷에 저장
        map.put(17, 1);     // 17.hashcode() % 16 = 1번째 버킷에 저장
        map.put(1, 100);    // 1.hashcode() % 16 = 1번째 버킷에 저장 --> 충돌이 발생했다!

        // 버킷내의 각 Node는 3가지의 값을 가진다. (key, value, next) -> next는 다음의 노드를 가리키는 듯
        // 이렇게 미리 생성된 버킷(ArrayList)에 해시연산을 통해서 특정 index를 결정하고 값이 저장된다.

        /*
        해시연산 후, 버킷의 인덱스 충돌이 발생하는 경우
        (17, 1) 데이터 앞에 (1, 100) 데이터를 저장하고 (1, 100) 노드의 next가 (17, 1)을 참조하도록 설정한다.
        ==> Separate Chaining 방식
         */

        // hashmap 내부 버킷에 저장 되었을 예상 인덱스 값 배치
        map.forEach((key, val) -> {
            System.out.println("key:"+key+", bucket index:"+key.hashCode() % 16);
        });

        /*
        hashmap에 저장된 데이터를 get() 할때는 어떻게 될까?
        get(10)하면 버킷내의 10번째 인덱스에 해당되는 값을 찾아서 반환한다.
        get(17)하면?
        - 해당 인덱스에는 두 개의 노드가 저장되어 있다.
        - 그러면 먼저 앞에 저장되어 있는 (1, 100) 노드를 확인하여 key값이 같은지 equals()를 수행하고 같으면 반환, 아니면 next가 가르키는 다음 노드를 확인한다.
        - 이 동작을 반복한다.

        해시충돌에 대한 대응법이 JDK7, JDK8이 서로 조금 다르다.
        - JDK7에서는 위에서 말한 것과 같이 충돌이 발생하면 연결리스트를 통해서 극복했다. 하지만 이는 데이터가 많이 쌓였을 때 느리다는 단점이 있다.
        (같은 index에 몇 천개의 노드가 저장되어 있다면,, 원하는 값을 찾을때까지 계속 순회할 것이기에,,)
        - JDK8에서는 리스트의 개수가 일정개수가 넘으면 Tree구조를 사용하도록 변경되었다.
         -> 이는 탐색속도를 O(log N)으로 향상시켜준다.
         -> 여기서 사용하는 트리는 Red-Black Tree를 사용한다.
         -> 충돌되어 쌓인 리스트가 8개 이상이면 리스트 -> 트리 형태로 변환
         -> 쌓인 리스트가 6개 이하로 감소하면 트리 -> 리스트로 변환
         */

        /*
        해시 버킷의 동적 확장
        - 아무런 설정없이 기본적으로 버킷의 개수는 16개이다. 그리고 로드 팩터는 0.75이다.
        - 로드팩터는 (데이터 개수/기본용량)이다. 이 로드팩터 값에 도달하면 버킷의 수를 2배 확장한다.
        (즉, 16개의 공간중에 12개가 차면 동적확장이 발생한다.)
        - 이 때, 버킷내에 저장되어 있던 데이터들의 새로운 버킷에 옮기는 작업이 발생하기에 너무 잦으면 성능상 좋지 않다.

        버킷 동적확장의 문제점
        - 버킷의 인덱스를 구할 때, 결국 현재의 capacity값을 가지고 X.hashcode() % CAPACITY 연산을 하게되는데, 2^a 연산만을 하게되니,,
          32비트 영역중에 특정한 a개의 비트만 사용하게되는 단점이 있음 ==> 해시충돌이 더 쉽게 발생 할 수 있다.
        ==> 보조해시함수가 필요한 이유
         */
    }
}
